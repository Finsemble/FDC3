---
id: raiseIntent
sidebar_label: raiseIntent
title: raiseIntent
---

Desktop Agent bridging message exchange for a `raiseIntent` API call on the [`DesktopAgent`](../../api/ref/DesktopAgent). Generated by API calls:

* [`raiseIntent(intent: string, context: Context, app: AppIdentifier)`](../api/ref/DesktopAgent#raiseintent)
* [`raiseIntentForContext(context: Context, app: AppIdentifier)`](../api/ref/DesktopAgent#raiseintentforcontext)

[Message Exchange Type](../spec#individual-message-exchanges): **Request Multiple Response (single)**

For Desktop Agent Bridging, a `fdc3.raiseIntent` call MUST always pass a `app: AppIdentifier` argument to target the intent. If a target `app` is not passed, then the `findIntent` message exchange should be used to collect options for the local resolver to use (note that Desktop Agents MAY also support the deprecated `raiseIntent` signature that uses the app `name` field by using the `findIntent` message exchange to attempt to resolve the `name` to an `AppIdentifier`). Once an option has been selected (for example because there is only one option, or because the user selected an option in a local intent resolver UI), the `raiseIntent` message exchange may then be used (if a remote option was selected as the resolution) to raise the intent.

e.g. An application with appId `agentA-app1` makes the following API call:

```javascript
let appIntent = await fdc3.raiseIntent("StartChat", context);
```

Agent A should then conduct the `findIntent` message exchange as described above, displaying its Intent resolver UI if necessary. Once an option is selected, the `raiseIntent` message exchange is conducted as if the API call had been made with a target app:

```javascript
let appIntent = await fdc3.raiseIntent("StartChat", context, {"appId": "Slack", "desktopAgent": "agent-B"});
```

:::info

The same approach applies to `fdc3.raiseIntentForContext` calls, in that a `findIntentByContext` message exchange should be used to collect options for the local resolver to use. Once an option has been selected (for example because there is only one option, or because the user selected an option in a local intent resolver UI), the `raiseIntent` message exchange is then used (if a remote option was selected as the resolution) to raise the intent.

:::

## Message exchange

:::note

Agent-C is not involved in the diagram below as the `raiseIntent` is always specified with a target application and Desktop Agent.

:::

```mermaid
sequenceDiagram
    participant DA as Desktop Agent A
    participant DAB as Desktop Agent Bridge
    participant DB as Desktop Agent B
    participant DC as Desktop Agent C
    DA ->>+ DAB: raiseIntent
    DAB ->>+ DB: raiseIntent
    DB -->>- DAB: raiseIntentResponse
    DAB -->>- DA: raiseIntentResponse
    DB ->>+ DAB: raiseIntentResultResponse
    DAB ->>+ DA: raiseIntentResultResponse
```

## Request format

Outward message to the DAB:

```json
// agent-A -> DAB
{
    "type": "raiseIntent",
    "payload": {
        "intent": "StartChat",
        "context": {/*contextObj*/},
        "app": { // AppIdentifier for chosen resolution including desktopAgent value
            "appId": "Slack",
            "desktopAgent": "agent-B"
            //Note an instanceId may be included to target an already running instance
        }
    },
    "meta": {
        "requestGuid": "<requestGuid>",
        "timestamp": "2020-03-...",
        "source": {
            "appId": "agentA-app1",
            "instanceId": "c6ad5174-6f78-4582-8e96-728d93a4d7d7"
        },
        "destination": { // duplicates the app argument so that the message is routed like any other
            "appId": "Slack",
            "desktopAgent": "agent-B"
        }
    }
}
```

The bridge fills in the `source.desktopAgent` field and forwards the request to the target Desktop Agent:

```json
// DAB -> agent-B
{
    "type": "raiseIntent",
    "payload": {
       "intent": "StartChat",
        "context": {/*contextObj*/},
        "app": {
            "appId": "Slack",
            "desktopAgent": "agent-B"
            //Note an instanceId may be included to target an already running instance
        }
    },
    "meta": {
        "requestGuid": "<requestGuid>",
        "timestamp": "2020-03-...",
        "source": {
            "appId": "agentA-app1",
            "instanceId": "c6ad5174-6f78-4582-8e96-728d93a4d7d7",
            "desktopAgent": "agent-A" //added by DAB
        },
        "destination": { // duplicates the app argument so that the message is routed like any other
            "appId": "Slack",
            "desktopAgent": "agent-B"
        }
    }
}
```

## Response format

If the `raiseIntent` request were made locally, agent-B would deliver the intent and context to the target app's `IntentHandler` and respond to the raising application with an `IntentResolution`:

```javascript
{
    "intent": "StartChat",
    "source": {
        "appId": "Slack",
        "instanceId": "e36d43e1-4fd3-447a-a227-38ec48a92706"   
    },
    getResult: Æ’
}
```

This is encoded and sent to the bridge (omitting the `getResult()` function) as:

```json
// agent-B -> DAB
{
    "type": "raiseIntentResponse",
    "payload": {
        "intentResolution": {
            "intent": "StartChat",
            "source": {
                "appId": "Slack",
                "instanceId": "e36d43e1-4fd3-447a-a227-38ec48a92706"      
            }
        }
    },
    "meta": {
        "requestGuid": "<requestGuid>",
        "responseGuid": "<responseGuid>",
        "timestamp": "2020-03-..."
    }
}
```

:::note

When producing a response to a `raiseIntent` request, the instance of the receiving application MUST be initialized and an `instanceId` generated for it before the `IntentResolution` is generated so that it may include the `instanceId`.

:::

The bridge will fill in the `intentResolution.source.DesktopAgent` & `source.desktopAgent` and relay the message back to agent-A:

```json
// DAB -> agent-A
{
    "type": "raiseIntentResponse",
    "payload": {
        "intentResolution": {
            "intent": "StartChat",
            "source": {
                "appId": "Slack",
                "instanceId": "e36d43e1-4fd3-447a-a227-38ec48a92706",
                "desktopAgent": "agent-B" // added by DAB
            }  
        }
    },
    "meta": {
        "requestGuid": "<requestGuid>",
        "responseGuid": "<responseGuid>",
        "timestamp": "2020-03-...",
        "sources": [{ "desktopAgent": "agent-B" }] // added by DAB
    }
}
```

When `Slack` produces an `IntentResult` from its `IntentHandler`, or the intent handler finishes running without returning a result, it should send a further `raiseIntentResultResponse` message to indicate that its finished running and to pass any `IntentResult` onto the raising application (setting either `payload.context` or `payload.channel` to indicate the type of the `IntentResult`).

```json
// agent-B -> DAB
{
    "type": "raiseIntentResultResponse",
    "payload": {
        "context": {/*contextObj*/}
        /* for a channel IntentResult use:
        "channel": {
            "id": "app-channel xyz",
            "type": "user"
        }
        */
    },
    "meta": {
        "requestGuid": "<requestGuid>",
        "responseGuid": "<responseGuid 2>", //a different GUID should be used for the result response
        "timestamp": "2020-03-...",
        "sources": [{
            "appId": "Slack",
            "instanceId": "e36d43e1-4fd3-447a-a227-38ec48a92706" //instance Id should be included now that its known
        }]
    }
}
```

:::tip

If intent result is private channel see [PrivateChannels](../spec#privatechannels) for additional message exchanges that may be needed.

:::

Finally, the bridge augments the response with `sources[0].desktopAgent` and passes it back to Agent-A.

```json
// DAB -> agent-A
{
    "type": "raiseIntentResultResponse",
    "payload": {
        "context": {/*contextObj*/}
    },
    "meta": {
        "requestGuid": "<requestGuid>",
        "responseGuid": "<responseGuid 2>",
        "timestamp": "2020-03-...",
        "sources": [{
            "appId": "Slack",
            "instanceId": "e36d43e1-4fd3-447a-a227-38ec48a92706",
            "desktopAgent": "agent-B" // added by DAB
        }]
    }
}
```

If the `IntentHandler` returned `void` rather than an intent result `payload` should be empty, e.g.:

```json
// DAB -> agent-A
{
    "type": "raiseIntentResultResponse",
    "payload": {},
    "meta": {
        "requestGuid": "<requestGuid>",
        "responseGuid": "<responseGuid 2>",
        "timestamp": "2020-03-...",
        "sources": [{
            "appId": "Slack",
            "instanceId": "e36d43e1-4fd3-447a-a227-38ec48a92706",
            "desktopAgent": "agent-B" // added by DAB
        }]
    }
}
```

:::note

In the event that an agent referred to in the API call is not connected to the bridge, it is connected but times out or returns an error, its `DesktopAgentIdentifier` should be added to the `meta.errorSources` element instead of `meta.sources` in the `raiseIntentResponse` and the appropriate error (which might include any error from the [`ResolveError`](../../api/ref/Errors#resolveerror) enumeration, [`BridgingError.ResponseTimedOut`](../../api/ref/Errors#bridgingerror) or [`BridgingError.AgentDisconnected`](../../api/ref/Errors#bridgingerror)) should be added to `meta.errorDetails`.

:::
